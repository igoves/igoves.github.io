---
title: "Ответы на вопросы компания MindK на тему Git"
date: "2021-04-30"
categories: 
  - "note"
tags: 
  - "answers"
  - "interview"
---

- Знаю, зачем нужна система контроля версий файлов и понимаю принцип ее работы.

Это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах.  С его помощью вы можете откатиться на более старую версию вашего проекта, сравнивать, анализировать, сливать изменения и многое другое. Этот процесс называется контролем версий

- Понимаю отличие архитектуры централизованной и распределенной системы контроля версий.

Централизованная система контроля версий предназначена для решения основной проблемы локальной системы контроля версий.

Для организации такой системы контроля версий используется единственный сервер, который содержит все версии файлов. Клиенты, обращаясь к этому серверу, получают из этого централизованного хранилища. Применение централизованных систем контроля версий на протяжении многих лет являлась стандартом. 

Для устранения единой точки отказа используются распределенные системы контроля версий. Они подразумевают, что клиент выкачает себе весь репозиторий целиком заместо выкачки конкретных интересующих клиента файлов. Если умрет любая копия репозитория, то это не приведет к потере кодовой базы, поскольку она может быть восстановлена с компьютера любого разработчика. Каждая копия является полным бэкапом данных.

- Понимаю и использовал основные команды работы с репозиторием GIT (init, clone, commit, push, pull, fetch).

```
git init // инициализирует проэкт
git clone https://github.com/libgit2/libgit2 // клонирование существующего репозитория
git add * // добавить все файлы к индексированию
git commit // зафиксировать измененные файлы
git push <remote-name> <branch-name> // отправка изменений в удаленный репозиторий
git pull // автоматически получить изменения из удалённой ветки и слить их со своей текущей
git fetch [remote-name] // получение изменений из удалённого репозитория
```

- Понимаю предназначение веток и использовал их в своей работе.

Это возможность открывать новый канал для особого набора изменений, например, для исправления бага, реализации новой фичи или каких-нибудь экспериментов — и все это без вреда для основной кодовой базы.

- Сливал ветки через merge.

Предположим, вы работаете над проектом и уже имеете несколько коммитов.  
Вы решаете, что теперь вы будете заниматься проблемой #53 из вашей системы отслеживания ошибок. Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду git checkout с параметром -b:

```
$ git checkout -b hotfix
Switched to a new branch "hotfix"
```

Это то же самое что и:

```
$ git branch hotfix
$ git checkout hotfix
```

Вы работаете над своим сайтом и делаете коммиты.

```
$ git commit -a -m 'Create hotfix'
$ git checkout master
Switched to branch 'master'
git merge hotfix
```

- Знаю применение команды stash + использовал её на практике.

Команда `git stash` позволяет на время «сдать в архив» (или _отложить_) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.

```
git stash    
git stash list    
git stash apply    
```

Отложенные изменения сохраняются в локальном репозитории Git и не передаются на сервер при выполнении команды push.

- Реализовывал конфликты.

 Если разработчик A попытается изменить код, который редактирует разработчик B, может произойти конфликт. Основная задача команды `git merge` заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

- Пересаживал цветы коммиты.

Команда `git cherry-pick` берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.

- Использовал команду rebase для перезаписи истории.

`git rebase` — это «автоматизированный» `cherry-pick`. Он выполняет ту же работу, но для цепочки коммитов, тем самым как бы перенося ветку на новое место.

- Знаю, как изменить последний коммит.

```
git commit --amend
```
