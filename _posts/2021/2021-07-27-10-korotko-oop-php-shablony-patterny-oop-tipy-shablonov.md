---
title: "10. Коротко ООП PHP - Шаблоны (паттерны) ООП. Типы шаблонов"
date: ""
categories: 
  - "php"
---

Любой понимает, что не каждый продавец на рынке, это профессиональный маркетолог или экономист, ему не обязательно знать такие понятия как моржа, амортизация, рои, дисконтирование, прогнозирование и другие умные слова. Но тем не менее он выполняет свою функцию, он продает. Так и с шаблонами, возможно вы их применяли на практике, просто не знали что это шаблон и у него есть название. Шаблоны делят на три ветки и они не привязаны к определенному языку программирования:  
  
**Порождающие** (Creational) - описывают механизм создания объекта и пытаются создать их в порядке, подходящем к ситуации.  
**Структурные** (Structural) - упрощают проектирование путем выявления простого способа реализовать отношения между субъектами.  
**Поведенческие** (Behavioral) - решают вопросы эффективного и безопасного взаимодействия между объектами.  
  
**Порождающие шаблоны**  
\- **Abstract Factory** (Абстрактная фабрика) - позволяет создавать целые группы взаимосвязанных объектов, которые, будучи созданными одной фабрикой, реализуют общее поведение.  
\- **Builder** (Строитель) - используется для отделения процесса конструирования сложного объекта от его представления, так что в результате одного и того же конструирования могут получаться различные объекты. Этот паттерн очень похож на абстрактную фабрику, но в нем акцентируется пошаговое конструирование объекта - в отличие от фабрики, где конструируется семейство классов.  
\- **Factory Method** (Фабричный метод) - предоставляет подклассам интерфейс для создания экземпляров некоторого класса.  
\- **Prototype** (Прототип) - используется для задания вида создаваемых объектов на основе объекта прототипа, от которого происходит передача внутреннего состояния (создаёт новые объекты путём копирования прототипа).  
  
**Структурные шаблоны**  
\- **Adapter** (Адаптер) - предназначен для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.  
\- **Bridge** (Мост) - используется для отделения абстракции от ее реализации так, чтобы и то и другое можно было изменять независимо.  
\- **Composite** (Компоновщик) - используется для компоновки объектов в древовидные структуры для представления иерархий, позволяя одинаково трактовать индивидуальные и составные объекты.  
\- **Decorator** (Декоратор) - используется для динамического расширения функциональности объекта. Является гибкой альтернативой наследованию.  
\- **Facade** (Фасад) - представляет собой унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы. Паттерн фасад определяет интерфейс более высокого уровня, который упрощает использование подсистем.  
\- **Flyweight** (Приспособленец) - используется для уменьшения затрат при работе с большим количеством мелких объектов.  
\- **Proxy** (Прокси) - который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).  
  
**Поведенческие шаблоны**  
\- **Chain of responsibility** (Цепочка обязанностей) - служит для ослабления связи между отправителем и получателем запроса. При этом сам по себе запрос может быть произвольным.  
\- **Command** (Команда) - представляет собой действие. Объект команды заключает в себе само действие и его параметры.  
\- **Interpreter** (Интерпретатор) - решает часто встречающуюся, но подверженную изменениям, задачу.  
\- **Iterator** (Итератор) - представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из агрегированных объектов.  
\- **Mediator** (Медиатор) - обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.  
\- **Memento** (Хранитель) - позволяет, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние.  
\- **Observer** (Наблюдатель) - создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними.  
\- **State** (Состояние) - используется в тех случаях, когда во время выполнения программы объект должен менять свое поведение в зависимости от своего состояния.  
\- **Strategy** (Стратегия) - предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путем определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.  
\- **Template Method** (Шаблонный метод) - определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.  
\- **Visitor** (Посетитель) - описывает операцию, которая должна быть выполнена над каждым объектом из некоторой произвольной структуры.  
  
Подробно о каждом шаблоне с примерами UML диаграммами и тестами, можно прочитать здесь:  
[https://nixsolutions.github.io/design-patterns/](https://dev.xfor.top/go/aHR0cHM6Ly9uaXhzb2x1dGlvbnMuZ2l0aHViLmlvL2Rlc2lnbi1wYXR0ZXJucy8%3D)  
[http://designpatternsphp.readthedocs.io/ru/latest/](https://dev.xfor.top/go/aHR0cDovL2Rlc2lnbnBhdHRlcm5zcGhwLnJlYWR0aGVkb2NzLmlvL3J1L2xhdGVzdC8%3D)  
[https://github.com/kamranahmedse/design-patterns-for-humans](https://dev.xfor.top/go/aHR0cHM6Ly9naXRodWIuY29tL2thbXJhbmFobWVkc2UvZGVzaWduLXBhdHRlcm5zLWZvci1odW1hbnM%3D)
