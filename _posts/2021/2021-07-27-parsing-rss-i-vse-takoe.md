---
title: "Парсинг RSS и все такое"
date: ""
categories: 
  - "php"
tags: 
  - "parse"
  - "rss"
  - "xml"
---

Ясен пень, что поисковики не любят дублирующий контент. Но иногда нужно, хоть тресни.  
  
**SimpleXML** – это расширение для PHP5 устанавливаемое в него по умолчанию, представляет самый простой и элегантный способ обработки XML файлов. Это и наиболее предпочтительный способ, но он стал доступным только в 5 версии PHP. Тут нет ничего проще, данный код наглядно показывает как просто парсить RSS ленты средствами SimpleXML:  

```
<?$url = 'rss.xml';       //адрес RSS ленты$rss = simplexml_load_file($url);       //Интерпретирует XML-файл в объект//цикл для обхода всей RSS лентыforeach ($rss->channel->item as $item) {        echo '<h1>'.$item->title.'</h1>';       //выводим на печать заголовок статьи         echo $item->description;        //выводим на печать текст статьи}?>
```

Данный код выведет заголовки и тексты статей из RSS ленты.  
  
**XML Parser Functions** - это стандартные функции PHP для работы с XML доступные начиная c 4-ой версии PHP. Продемонстрирую пример:  

```
<?$url = 'rss.xml';       //адрес RSS ленты$xml = xml_parser_create();     //создаёт XML-разборщикxml_parser_set_option($xml, XML_OPTION_SKIP_WHITE, 1);  //устанавливает опции XML-разборщикаxml_parse_into_struct($xml, file_get_contents($url), $element, $index); //разбирает XML-данные в структуру массиваxml_parser_free($xml);  //освобождает XML-разборщик$count = count($index["TITLE"])-1;      //число проходов цикла.for ($i=0; $i < $count; $i++) {        echo '<h1>'.$element[$index["TITLE"][$i+1]]["value"].'</h1>';           //выводим на печать заголовок статьи         echo $element[$index["DESCRIPTION"][$i+1]]["value"];            //выводим на печать текст статьи}?>
```

Мы получаем интересующие нас содержимое элементов RSS. Но тут уже нужно разобраться с массивами которые создает XML разборщик.  
  
Приведу небольшой пример парсинга RSS обычным процедурным PHP кодом, тут за парсинг отвечает функция preg\_match\_all(), которая выполняет глобальный поиск шаблона в строке. Данный пример не совершенен и парсит только титлы и дескрипшены у RSS:  

```
<?$url = 'rss.xml';       //адрес RSS ленты$rss = @file_get_contents($url);        //получаем содержимое RSS лент в виде одной строкиif ($rss) {             preg_match_all("/title>[^>]+>/", $rss, $title);         //парсим титлы        preg_match_all("/<description>[^<]+</description>/", $rss, $description);              //парсим дескрипшены                $count = count($title[0])-1;    //число проходов цикла.                for ($i=0; $i < $count; $i++) {                echo '<h1>'.substr($title[0][$i+1], 6, -8).'</h1>';             //выводим на печать заголовок статьи                 echo substr($description[0][$i], 13, -14);              //выводим на печать текст статьи        }} else {        echo '<font color="red">Ошибка парсинга '.$url.'</font>';       //выводим ошибку если file_get_contents() вернула false}?>
```

Таким же способом можно и отпарсить остальные элементы RSS ленты, главное написать правильно регулярку.  
  
RSS ленты как правило находятся в кодировке UTF-8, при парсинге русского текста тремя способами описанными выше, нам на экран выводятся кракозябры. Все потому, что тест к нам приходит в кодировке UTF-8. Для того что бы вывести нормальные РУССКИЕ буквы нужно перекодировать спарсеный текст из кодировки UTF-8 в Windows-1251. Для этих целей в PHP существует функция iconv(), но она доступна не на всех серверах и чтобы избежать дальнейших проблем с вашим RSS парсером советую использовать самописную функцию перекодировки. Вникать в тонкости кодировок и разбираться как из одной кодировки получается другая думаю вам не хочется, так же не хотелось и мне. Немного погуглив я нашел замечательную функцию перекодировки из UTF-8 в Windows-1251 и обратно, предоставляет ее некий товарищ E64F. Возможно конечно он тоже ее где-то слямзил, но это не так важно, важно то что она мне очень понравилась по сравнению с другими нагуглеными функциями. Выкладываю функцию и пример ее использования:  

```
<?echo utf8_convert($str, "w");   //перекодирует $str из UTF-8 в Windows-1251 и выведет на экран{   static $conv = '';   if (!is_array($conv))   {      $conv = array();      for ($x=128; $x <= 143; $x++)      {         $conv['utf'][] = chr(209) . chr($x);         $conv['win'][] = chr($x + 112);      }      for ($x=144; $x<= 191; $x++)      {         $conv['utf'][] = chr(208) . chr($x);         $conv['win'][] = chr($x + 48);      }      $conv['utf'][] = chr(208) . chr(129);      $conv['win'][] = chr(168);      $conv['utf'][] = chr(209) . chr(145);      $conv['win'][] = chr(184);   }   if ($type == 'w')   {      return str_replace($conv['utf'], $conv['win'], $str);   }   elseif ($type == 'u')   {      return str_replace($conv['win'], $conv['utf'], $str);   }   else   {      return $str;   }}?>
```

Функция utf8\_convert() принимает 2 параметра: $str – наша строка которую нужно перекодировать и $type – в какую кодировку нужно кодировать (“w” – из utf в win, “u” – из win в utf). Как это применить к нашим 3-м способам парсинга RSS думаю разберетесь, если хоть немного знаете PHP.
