---
title: "Ответы на вопросы компании MindK на тему PHP"
date: "2021-05-03"
categories: 
  - "note"
tags: 
  - "interview"
  - "work"
---

❏ Знаю какие задачи решаются с помощью mod\_rewrite.  
Модуль Апач, служит для манипуляций над урлом

❏ Реализовывал 301-редирект с помощью mod\_rewrite.

```
Redirect 301 /was.php http://www.site.ru/new.php
```

❏ Настраивал перенаправления для реализации единой точки входа в приложение с помощью mod\_rewrite.

```
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 [L]
```

❏ Знаю, что такое HTTP Authentication и настраивал ее.

```
AuthName "Текст выводится в окне авторизации"
AuthType Basic
AuthUserFile Полный путь/.htpasswd
require valid-user
```

❏ Знаю назначение магических методов и применял их на практике.

```
__construct() - этот метод запускается автоматически при созданнии экземпляра класса
__destruct() - метод запускается автоматически при уничтожении обьекта
__call(), __callStatic() - перехватывают обращение к несуществующему методу в контексте объекта и в статическом контексте
__get(), __set() - выполняется при чтении/записи данных из недоступных свойств
__isset() - будет выполнен при использовании isset() или empty() на недоступных свойствах
__unset() - будет выполнен при вызове unset() на недоступном свойстве
__sleep() - вызывается, когда объект подвергается сериализации при помощи функции serialize()
__wakeup() - вызывается при восстановлении объекта при помощи функции unserialize()
__toString() - метод, с помощью которого можно обращаться к классу как к строке
__invoke() - вызывается при попытке использовать объект в качестве функции
__set_state() - метод, который вызывается для классов, экспортирующих значения свойств функцией var_export()
__clone() - вызывается при клонировании объекта
__debugInfo() - метод вызывается функцией var_dump(), когда необходимо вывести список свойств объекта
```

❏ Понимаю и использовал в своей работе Iterator (из SPL).

SPL - Стандартная библиотека PHP

```
// Метод должен вернуть значение текущего элемента
public function current();
// Метод должен вернуть ключ текущего элемента
public function key();
// Метод должен сдвинуть "указатель" на следующий элемент
public function next(): void;
// Метод должен поставить "указатель" на первый элемент
public function rewind(): void;
// Метод должен проверять - не вышел ли указатель за границы?
public function valid(): bool
```

Строго говоря, итерироваться с помощью foreach нам позволяет интерфейс Traversable, а Iterator является его наследником. Особенность Traversable заключается в том, что его нельзя реализовать напрямую (этакий «абстрактный интерфейс») и пользоваться в своих приложениях нужно всё-таки интерфейсом Iterator или его «младшим братом» IteratorAggregate.

❏ Понимаю и использовал в своей работе ArrayObject (из SPL).  
Чтобы объект вёл себя как массив, даёт доступ к данным через квадратные скобки и позволяет делать foreach

❏ Понимаю зачем нужна Reflection и могу привести практический пример применения.

```
class Child extends Profile {}
$class = new ReflectionClass('Child');
// получаем список всех родителей
print_r($class->getParentClass()); // ['Profile']
```

❏ Знаю новшества 7. 
use Framework\\Module{Foo, Bar, Baz};  
$bar = $foo ?? 'default';  
Оператор “космический корабль” <=>  
типы скалярных параметров и подсказки (hints)  
анонимные классы  
и многое другое https://www.php.net/manual/ru/doc.changelog.php

❏ Понимаю зачем нужны анонимные функции и могу привести хотя бы 1 пример использования.

```
$greet = function($name) { printf("Привет, %s\r\n", $name); };
```

❏ Понимаю какую проблему решает Autoloading и умею написать свою реализацию.  
Автозагрузка классов

```
function __autoload($className) {
  $filename = $className . ".php";
  if (is_readable($filename)) {
    require $filename;
  }
}
```

❏ Понимаю какую проблему решает паттерн Front Controller и могу реализовать его на практике.  
Один контроллер обрабатывает все запросы к веб-сайту. Фронт-контроллер - это единая точка входа для вашего приложения.  
www.example.com/**index.php**?article=3  
www.example.com/**index.php**?user=4

❏ Понимаю какую проблему решает паттерн Page Controller и могу реализовать его на практике.

Паттерн, в котором один контроллер отвечает за отображение одной логической страницы. Это может быть как отдельная страница, хранящаяся на веб-сервере, так и отдельный объект, который отвечает за страницу.  
www.example.com/**article.php**?id=3  
www.example.com/**user.php**?id=4

❏ Понимаю какую проблему решает паттерн MVC и могу реализовать его на практике.  
Модель – вид - контроллер

- Контролёр указывает модели **что нужно сделать**.
- Модель **выполняет работу**.
- Вид **отображает/отдаёт результат**.

❏ Понимаю какую проблему решает паттерн HMVC и могу реализовать его на практике.  
Иерархичекий – модель – вид - контроллер

Паттерн Иерархические-Модель-Вид-Контроллер (HMVC) является расширением MVC

❏ Знаю хотя бы один способ реализации роутинга в веб-приложении.  
switch $\_GET\[‘action’\] или parse\_url

❏ Понимаю как обеспечить безопасную работу с входящим запросом и могу предложить варианты реализации. В частности, как предотвращать CSRF-атаки, XSS фильтр.  
CSRF – внедрением токеонов, XSS – шифрование входных данных в сущности

❏ Знаю, что такое SQL-инъекции и могу обеспечить безопасную работу с БД.

Использовать PDO и фильтровать входящие данные

❏ Умею настроить нужный уровень ошибок.

```
error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);
```

❏ Знаю, как переопределить переменные окружения через htaccess/virt-hosts.

```
SetEnv Foo "bar"
echo $_SERVER["Foo"];
```

❏ Смогу найти все ссылки в тексте с помощью reg-выражений.

```
<a href="(.+?)">(.+?)</a>
```

❏ Работал с URL-библиотекой.

❏ Знаю, что такое сессия и как с ней работать. Могу реализовать свою ООП-реализацию.  
`session_set_save_handler('sess_open',  
'sess_close',  
'sess_read',  
'sess_write',  
'sess_destroy',  
'sess_gb' );  
session_start();`

❏ Знаю, как дописать содержимое в файл средствами PHP.

```
file_put_contents($filename, $data, FILE_APPEND);
```

❏ Умею удалять файлы и директории из PHP.  
Файлы — unlink, директории - rmdir

❏ Могу написать обработчик загрузки файла с html формы.

```
<form enctype="multipart/form-data" action="__URL__" method="POST">
    Отправить этот файл: <input name="userfile" type="file" />
    <input type="submit" value="Отправить файл" />
</form>
```

```
move_uploaded_file($_FILES['userfile']['tmp_name'], /dir/to/file.ext)
```

❏ Знаю как писать консольные скрипты на PHP.

```
#!/usr/bin/env php
<?php
printf('There were %d arguments passed to PHP:' . PHP_EOL, $argc);
print_r($argv);
```

❏ Умею построить работу с обработкой ошибок в приложении с использованием Exceptions.

```
try { } catch (Exception $e) {}
```

❏ Имею опыт реализации валидации входных данных.  
FILTER\_VALIDATE\_ email domain int float ip Boolean url regexp url

❏ Имею опыт реализации загрузки файлов через форму.

```
move_uploaded_file($_FILES['userfile']['tmp_name'], /dir/to/file.ext)
```

❏ Знаю, что такое ACL и хотя бы раз реализовывал  
Список управления доступом

❏ Знаю какие драйверы баз данных поддерживаются PHP с коробки.  
Без модулией не поддерживает никакие базы данных. С модулями: sqlite, mongodb, myslq, mssql, maxdb, postgresql и другие.

❏ Использовал PDO.

```
<?php
try {
    $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
    foreach($dbh->query('SELECT * from FOO') as $row) {
        print_r($row);
    }
    $dbh = null;
} catch (PDOException $e) {
    print "Error!: " . $e->getMessage() . "<br/>";
    die();
}
```

❏ Понимаю какую проблему решает ActiveRecord и имею опыт реализации.

Active Record обеспечивает объектно-ориентированный интерфейс для доступа и манипулирования данными, хранящимися в базах данных. Класс Active Record соответствует таблице в базе данных, объект Active Record соответствует строке этой таблицы, а атрибут объекта Active Record представляет собой значение отдельного столбца строки. Вместо непосредственного написания SQL-выражений вы сможете получать доступ к атрибутам Active Record и вызывать методы Active Record для доступа и манипулирования данными, хранящимися в таблицах базы данных.

```
$customer = new Customer();
$customer->name = 'Qiang';
$customer->save();
```

❏ Знаю плюсы и минусы DataMapper и ActiveRecord.

Оба эти паттерна предназначаются для преобразования данных из реляционного представления в объектное. Разница в том как они это делают и как они организованы, если в вкратце:  
**ActiveRecord** \- это объект, который хранит данные и содержит логику взаимодействия с БД.  
Преимущества: простота, удобно использовать на небольших проектах.  
Недостатки: паттерн нарушает множество принципов в частности Single Responsibility Principle, его использование как правило делает код сильно связанным, из за чего на сложных проектах его использовать невозможно.  
**DataMapper** \- объект хранящий логику взаимодействия с БД. Он не хранит данные как ActiveRecord  
Преимущества: позволяет построить слабосвязанную архитектуру, разделить приложения на слои.  
Недостатки: более сложный

❏ Имею практический опыт разработки на одном из современных фреймворков, таких как Laravel, Symfony, Yii, Zend.  
Laravel https://laravel.com
